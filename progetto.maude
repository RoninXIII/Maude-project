mod GRID is
    protecting INT .
    protecting STRING .
    protecting BOOL .
    sort Grid Place Coordinate .
    subsort Place < Grid .
    subsort Coordinate < Int .
    
    op 1 2 3 4 : -> Coordinate [ctor] .
    op empty : -> Int [ctor format (b! o)] .
    op result : Grid -> Int [ctor format (r! o)] .
    op sq : Coordinate Coordinate Int -> Place .
    op sq : Coordinate Coordinate String -> Place  . *** La stringa indica sia una cella vuota sia una cella contenente un operatore

    op __ : Grid Grid -> Grid  [assoc] .
    op write : Int  -> Int . *** Sostituisce un numero giÃ  presente
    
    ***op row : Grid -> Grid .
   *** op column : Grid -> Grid .
    op isValid : Grid -> Bool .
    op isResult : Grid -> Bool .
    op initial : -> Grid  .


    vars I J : Coordinate . *** Coordinata
    vars N1 N2 N3 N4 : Int . *** I numeri possibili che si possono inserire. Sono tanti quante le celle "scrivibili".
    var G : Grid .
    var RR1 RR3 RC1 RC3 : Int . *** I risultati corrispondenti alle righe 1-3 ed alle colonne 1-3.
    var O1 O2 O3 O4 : String . *** Gli operatori

    ***eq row(sq(I,J,N1) sq(I,J,O1) sq(I,J,N2) G) =  .
    
    eq isValid(sq(I,J,1) sq(I,J,1) G) = false .
    eq isValid(sq(I,J,2) sq(I,J,2) G) = false .
    eq isValid(sq(I,J,3) sq(I,J,3) G) = false .
    eq isValid(sq(I,J,4) sq(I,J,4) G) = false .
    eq isValid(sq(I,J,5) sq(I,J,5) G) = false .
    eq isValid(sq(I,J,6) sq(I,J,6) G) = false .
    eq isValid(sq(I,J,7) sq(I,J,7) G) = false .
    eq isValid(sq(I,J,8) sq(I,J,8) G) = false .
    eq isValid(sq(I,J,9) sq(I,J,9) G) = false .
    eq isValid(G) = true [owise].
    *** red isValid(sq(I,J,write(empty)) sq(I,J,1) G) .
    eq write(empty) = 1 .
    eq write(1) = 2 .
    eq write(2) = 3 .
    eq write(3) = 4 .
    eq write(4) = 5 .
    eq write(5) = 6 .
    eq write(6) = 4 .
    eq write(7) = 5 .
    eq write(8) = 9 .
    eq write(9) = empty .
    
 


    --- result prende in input 4 celle (2 con i numeri inseriti, 1 con un operatore e l'ultima con il risultato da ottnere)

   eq result(sq(I,J,N1) sq(I,J,"+") sq(I,J,N2) G) = N1 + N2 .
   eq result(sq(I,J,N1) sq(I,J,"+") sq(I,J,N3) G) = N1 + N3 .
   eq result(sq(I,J,N2) sq(I,J,"+") sq(I,J,N4) G) = N2 + N4 .
   eq result(sq(I,J,N3) sq(I,J,"+") sq(I,J,N4) G) = N3 + N4 .

   eq result(sq(I,J,N1) sq(I,J,"*") sq(I,J,N2) G) = N1 * N2 .
   eq result(sq(I,J,N1) sq(I,J,"*") sq(I,J,N3) G) = N1 * N3 .
   eq result(sq(I,J,N2) sq(I,J,"*") sq(I,J,N4) G) = N2 * N4 .
   eq result(sq(I,J,N3) sq(I,J,"*") sq(I,J,N4) G) = N3 * N4 .



   eq result(sq(I,J,N1) sq(I,J,"-") sq(I,J,N2) G) = N1 - N2 .
   eq result(sq(I,J,N1) sq(I,J,"-") sq(I,J,N3) G) = N1 - N3 .
   eq result(sq(I,J,N2) sq(I,J,"-") sq(I,J,N4) G) = N2 - N4 .
   eq result(sq(I,J,N3) sq(I,J,"-") sq(I,J,N4) G) = N3 - N4 .

    

    ceq isResult(sq(I,J,N1) sq(I,J,O1) sq(I,J,N2) sq(I,J,RR1) G) = false
        if result(sq(I,J,N1) sq(I,J,O1) sq(I,J,N2) G) =/= RR1 .

    ceq isResult(sq(I,J,N3) sq(I,J,O2) sq(I,J,N4) sq(I,J,RR3) G) = false
        if result(sq(I,J,N3) sq(I,J,O2) sq(I,J,N4) G) =/= RR3 .

    ceq isResult(sq(I,J,N1) sq(I,J,O3) sq(I,J,N3) sq(I,J,RC1) G) = false
        if result(sq(I,J,N1) sq(I,J,O3) sq(I,J,N3) G) =/= RC1 .
        
    ceq isResult(sq(I,J,N2) sq(I,J,O4) sq(I,J,N4) sq(I,J,RC3) G) = false
        if result(sq(I,J,N2) sq(I,J,O4) sq(I,J,N4) G) =/= RC3 .

    eq isResult(G) = true [owise] .
    
    eq initial = sq(1,1,empty) sq(1,2,"+") sq(1,3,empty) sq(1,4,11)
                sq(2,1,"*") sq(2,2,empty) sq(2,3,"+") sq(2,4,empty)
                sq(3,1,empty) sq(3,2,"*") sq(3,3,empty) sq(3,4,45)
                sq(4,1,20) sq(4,2,empty) sq(4,3,16) sq(4,4,empty)
                 .     


   rl [write-row] : sq(1,J,N1) sq(1,J,O1) sq(1,J,N2) sq(1,J,RR1)
                     sq(2,J,O2) sq(2,J,0) sq(2,J,O3) sq(2,J,0)
                     sq(3,J,N3) sq(3,J,O4) sq(3,J,N4) sq(3,J,RR3)
                     sq(4,J,RC1) sq(4,J,0) sq(4,J,RC3) sq(4,J,0) => 
                     sq(1,J,write(N1)) sq(1,J,O1) sq(1,J,N2) sq(1,J,11)
                     sq(2,J,O2) sq(2,J,0) sq(2,J,O3) sq(2,J,0)
                     sq(3,J,N3) sq(3,J,O4) sq(3,J,N4) sq(3,J,45)
                     sq(4,J,20) sq(4,J,0) sq(4,J,16) sq(4,J,0)
                         .

                                          

--- search initial =>* G:Grid such that isResult(G: Grid) .          
--- rew [1] initial .               
endm

